import type {
  Schema,
  ValidationResult,
  ValidationError,
} from "../schema/types";
import type { SchemaBuilder } from "../schema/builders";

/**
 * WASM module interface
 * Auto-generated by wasm-pack
 */
export interface WasmModule {
  WasmValidator: {
    validate(schema_json: string, value_json: string): string;
    validate_at_path(
      schema_json: string,
      value_json: string,
      path_json: string,
    ): string;
  };
}

/**
 * Lazy-loaded WASM module singleton
 */
let wasmModule: WasmModule | null = null;
let wasmInitPromise: Promise<void> | null = null;

/**
 * Initialize WASM module
 * Can be called explicitly for eager loading, or will auto-initialize on first use
 */
export async function initWasm(): Promise<void> {
  if (wasmModule) return;
  if (wasmInitPromise) return wasmInitPromise;

  wasmInitPromise = (async () => {
    try {
      // Dynamic import of WASM module
      const module = (await import("../../pkg/rustica.js")) as any;

      console.log("WASM module loaded:", module);
      console.log("Has WasmValidator?", !!module.WasmValidator);
      console.log("Has default?", typeof module.default);

      // For bundler/web target with async init, call default function
      if (typeof module.default === "function") {
        await module.default();
      }

      // Always set wasmModule to the imported module (it has WasmValidator)
      wasmModule = module;

      // Verify WasmValidator is accessible
      if (!module.WasmValidator) {
        throw new Error("WasmValidator not found in WASM module");
      }

      console.log("WASM initialization complete");
    } catch (error) {
      console.error("WASM initialization failed:", error);
      wasmInitPromise = null; // Reset on error so it can be retried
      throw new Error(
        `Failed to load WASM module. Make sure to run 'npm run build:wasm' first. Error: ${error}`,
      );
    }
  })();

  return wasmInitPromise;
}

/**
 * Get initialized WASM module (auto-initializes if needed)
 */
async function getWasm(): Promise<WasmModule> {
  // If initialization is in progress, wait for it
  if (wasmInitPromise && !wasmModule) {
    await wasmInitPromise;
  }

  // If not initialized at all, start initialization
  if (!wasmModule) {
    await initWasm();
  }

  // Final check
  if (!wasmModule) {
    throw new Error(
      "WASM module not initialized. Call initWasm() before validation.",
    );
  }

  return wasmModule;
}

/**
 * Core validator using WASM
 */
export class Validator {
  /**
   * Validate data against a schema
   * Auto-initializes WASM on first use
   *
   * @param schema - Schema definition (builder or JSON)
   * @param value - Data to validate
   * @returns Validation result with errors if any
   */
  static async validate<T>(
    schema: SchemaBuilder<T> | Schema,
    value: unknown,
  ): Promise<ValidationResult> {
    const wasm = await getWasm();

    // Serialize schema to JSON
    const schemaJson = JSON.stringify(
      schema instanceof Object && "toJSON" in schema ? schema.toJSON() : schema,
    );

    // Serialize value to JSON
    const valueJson = JSON.stringify(value);

    // Call WASM validator (single call, zero-copy)
    const resultJson = wasm.WasmValidator.validate(schemaJson, valueJson);

    // Parse result
    return JSON.parse(resultJson) as ValidationResult;
  }

  /**
   * Validate data at a specific path in the schema
   * Useful for field-level validation in forms
   * Auto-initializes WASM on first use
   *
   * @param schema - Schema definition
   * @param value - Complete data object
   * @param path - Path to validate (e.g., ['user', 'email'])
   * @returns Validation result for the specific field
   */
  static async validateAtPath<T>(
    schema: SchemaBuilder<T> | Schema,
    value: unknown,
    path: string[],
  ): Promise<ValidationResult> {
    const wasm = await getWasm();

    // Serialize inputs
    const schemaJson = JSON.stringify(
      schema instanceof Object && "toJSON" in schema ? schema.toJSON() : schema,
    );
    const valueJson = JSON.stringify(value);
    const pathJson = JSON.stringify(path);

    // Call WASM validator (single call)
    const resultJson = wasm.WasmValidator.validate_at_path(
      schemaJson,
      valueJson,
      pathJson,
    );

    // Parse result
    return JSON.parse(resultJson) as ValidationResult;
  }

  /**
   * Validate and throw on error (for convenience)
   * Auto-initializes WASM on first use
   */
  static async parse<T>(
    schema: SchemaBuilder<T> | Schema,
    value: unknown,
  ): Promise<T> {
    const result = await this.validate(schema, value);

    if (!result.success) {
      throw new ValidationException(result.errors || []);
    }

    return value as T;
  }

  /**
   * Safe parse that returns result object
   * Auto-initializes WASM on first use
   */
  static async safeParse<T>(
    schema: SchemaBuilder<T> | Schema,
    value: unknown,
  ): Promise<
    { success: true; data: T } | { success: false; errors: ValidationError[] }
  > {
    const result = await this.validate(schema, value);

    if (result.success) {
      return { success: true, data: value as T };
    } else {
      return { success: false, errors: result.errors || [] };
    }
  }
}

/**
 * Validation exception for parse() method
 */
export class ValidationException extends Error {
  constructor(public errors: ValidationError[]) {
    super(
      "Validation failed:\n" +
        errors.map((e) => `  - ${e.path.join(".")}: ${e.message}`).join("\n"),
    );
    this.name = "ValidationException";
  }
}

/**
 * Auto-initialization wrapper
 * Automatically initializes WASM on first use
 */
export async function createValidator(): Promise<typeof Validator> {
  await initWasm();
  return Validator;
}
